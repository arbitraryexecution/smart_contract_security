const hre = require("hardhat");
const ethers = hre.ethers;

async function main() {
  // set up two wallets
  const [deployer, exploiter] = await ethers.getSigners();
  const initialBalance = await ethers.provider.getBalance(exploiter.address);

  console.log(`***** Wallets\n`);
  console.log(`deployer:\t${deployer.address}\nexploiter:\t${exploiter.address}\n\n`);

  const Array = await hre.ethers.getContractFactory("Array", deployer);
  const array = await Array.deploy({value: ethers.utils.parseEther("10")});

  const Exploit = await hre.ethers.getContractFactory("Exploit", exploiter);
  const exploit = await Exploit.deploy(array.address);

  await exploit.deployed();

  console.log("***** Contract\n");
  console.log(`Array deployed to:\t${array.address}\nbalance:\t${await ethers.provider.getBalance(array.address)}\n\n`);
  console.log(`Exploit deployed to:\t${exploit.address}\nbalance:\t${await ethers.provider.getBalance(exploit.address)}\n\n`);

  const sentinel = "0x1337133713371337133713371337133713371337133713371337133713371337"

  console.log("***** Setup\n");
  console.log(`pushing recognisable bytes32 (${sentinel}) for testing\n\n`); 

  array.push(sentinel);

  console.log("***** Storage\n");
  for (i = 0; i < 3; i ++) {
    console.log(`slot \t${i}: ${await ethers.provider.getStorageAt(array.address, i)}`);
  }

  // Dynamic arrays are laid out with their length in their initial slot
  // and their 1st element at the keccak256 hash of their initial slot
  //
  // In this case, the array is at slot 1 so the first element is at
  // keccak256("0x0000000000000000000000000000000000000000000000000000000000000001")

  const elementsSlot = ethers.utils.solidityKeccak256(["uint256"], [1]);
  console.log(`\nThe 1st array element will be at slot ${elementsSlot}`);
  console.log(`slot lookup: ${await ethers.provider.getStorageAt(array.address, elementsSlot)}\n\n`);

  console.log(`***** Calling exploit (will fail if exploit doesn't steal ownership)\n`);

  await exploit.exploit();

  const stollen = await ethers.provider.getBalance(exploiter.address) - initialBalance;
  console.log(`Amount stollen from exploit: ${stollen}\n\n`);

  if (stollen > 0) {
    console.log(`Nice work! You stole the funds!`);
  } else {
    console.log(`No Ether was stollen :( try again`);
  }

}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
